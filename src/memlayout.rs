/* Physical memory layout
 * qemu -machine virt is set up like this,
 * based on qemu's hw/riscv/virt.c:
 *
 * 00001000 -- boot ROM, provided by qemu
 * 02000000 -- CLINT
 * 0C000000 -- PLIC
 * 10000000 -- uart0
 * 10001000 -- virtio disk
 * 80000000 -- boot ROM jumps here in machine mode
 *             -kernel loads the kernel here
 * unused RAM after 80000000.
 *
 * the kernel uses physical memory thus:
 * 80000000 -- entry.S, then kernel text and data
 * end -- start of kernel page allocation area
 * PHYSTOP -- end RAM used by the kernel
 */

use crate::riscv::{MAXVA, PGSIZE};

// qemu UART registers
pub const UART0: usize = 0x1000_0000;
pub const UART0_IRQ: usize = 10;

// virtio mmio interface
pub const VIRTIO0: usize = 0x1000_1000;
pub const VIRTIO0_IRQ: usize = 1;

// Core Local Interrupter (CLINT), contains the timer
pub const CLINT: usize = 0x200_0000;
pub const CLINT_MTIME: usize = CLINT + 0xBFF8; // Cycles since boot

pub const fn clint_mtimecmp(hart: usize) -> usize {
    CLINT + 0x4000 + 8 * hart
}

// Platform-Level Interrupt Controller (PLIC)
pub const PLIC: usize = 0x0C00_0000;
pub const fn plic_senable(hart: usize) -> usize {
    PLIC + 0x2000 + hart * 0x100
}
pub const fn plic_spriority(hart: usize) -> usize {
    PLIC + 0x201000 + hart * 0x2000
}

// Physical RAM resides from KERNBASE to PHYSTOP
pub const KERNBASE: usize = 0x8000_0000;
pub const PHYSTOP: usize = KERNBASE + (128 * 1024 * 1024);

// Trampoline is the highest address in both user and kernel space
pub const TRAMPOLINE: usize = MAXVA - PGSIZE;

// Kernel stack is beneath the trampoline
// Each surrounded by invalid guard pages
pub const fn kstack(p: usize) -> usize {
    TRAMPOLINE - (p + 1) * (2 * PGSIZE)
}

/*
 * User memory layout:
 * Address zero first:
 *   text
 *   original data and bss
 *   fixed-size stack
 *   expandable heap
 *   ...
 *   TRAPFRAME (p->trapframe, used by the trampoline)
 *   TRAMPOLINE (the same page as in the kernel)
 */
pub const TRAPFRAME: usize = TRAMPOLINE - PGSIZE;

/*
 * xv6 rusn on Sv39 RISC-V -> bottom 39 bits of 64-bit virtual address is used (top 25 bits unused)
 *
 * a page table is an array of 2^27 page table entries (PTEs)
 *
 * each PTE contains a 44-bit physical page number (PPN) and some flags
 *
 * hardware uses top 27 bits of the 39 bits to index into the page table to find a PTE
 * then, it makes a 56-bit physical address whose top 44 bits come from the PPN in the PTE and
 * bottom 12 bits are copied from the original virtual address
 *
 * 12-bit offset -> 4k aligned chunks (pages)
 *
 * 3 layers of page tables -> PPN has 3 9-bit addresses -> each points to 512 PTE
 *
 * cpu will translate all addresses generated by subsequent instruction using the page table
 * pointed to by its own `satp`. `satp` should be set to the root page-table.
 *
 * each cpu has its own `satp` and paging hardware, so each can run different virtual addresses
 *
 *      63  10bit   53     44bit       9 10bit 0
 * PTE: [ Reserved  ][      PPN       ][ flags ]
 *
 *      63    25bit     38   27bit   11 12bit  0
 * VA:  [      EXT      ][   Index   ][ Offset ]
 *
 *      63  8bit   55     44bit      11 12bit  0
 * PA:  [ Reserved ][      PPN       ][ Offset ]
 *
 * Flags:
 * [0]: V - Valid
 * [1]: R - Readable
 * [2]: W - Writable
 * [3]: X - Executable
 * [4]: U - User
 * [5]: G - Global
 * [6]: A - Accessed
 * [7]: D - Dirty (0 in page directory)
 * [10:8]: Reserved for supervisor software
 */
